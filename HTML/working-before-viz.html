<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Turing Machine Editor</title>
  <link href="https://fontlibrary.org/face/osp-din" rel="stylesheet" type="text/css">
  <style>
    :root {
      --bg: #000;
      --text: #fff;
      --accent: #d4af37;
    }

    body {
      font-family: 'OSP-DIN', sans-serif;
      background-color: var(--bg);
      color: var(--text);
      margin: 0;
      padding: 2rem;
    }

    h1 {
      text-transform: uppercase;
      font-weight: normal;
      letter-spacing: 1px;
      font-size: 2.5em;
      margin-bottom: 0.5rem;
    }

    #versionInfo {
      font-size: 1rem;
      color: var(--accent);
      margin-bottom: 1rem;
    }

    #midiError {
      color: red;
      font-weight: bold;
      margin-bottom: 2rem;
      display: none;
    }

    .config-grid {
      display: grid;
      grid-template-columns: auto repeat(var(--preset-count, 2), 1fr);
      gap: 2rem;
    }

    .grid-header,
    .field-label {
      text-transform: uppercase;
      font-weight: bold;
      font-size: 1.25em;
    }

    .field-label {
      border-left: 4px solid var(--accent);
      padding-left: 1rem;
    }

    .field-cell {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }

    button {
      font-family: 'OSP-DIN', sans-serif;
      font-size: 1.2em;
      background-color: var(--bg);
      color: var(--text);
      border: 2px solid var(--accent);
      padding: 0.7em 1.2em;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
    }

    button:hover {
      background-color: #111;
    }

    button.active {
      background-color: var(--text);
      color: var(--bg);
      border-color: var(--text);
    }

    @media (max-width: 800px) {
      .config-grid {
        grid-template-columns: auto 1fr;
      }
      .config-grid .grid-header:nth-child(n+3),
      .config-grid .field-cell:nth-child(3n+3) {
        display: none;
      }
    }
  </style>
</head>
<body>
  <h1>Turing Machine Editor</h1>
  <p id="versionInfo">Loading version info...</p>
  <p id="midiError">No MIDI device connected.</p>
  <div id="config" class="config-grid"></div>

  <script>
    const presets = [
      { name: "Scale", key: "scale", labels: ["Chrom", "Major", "Minor", "Minor Pent", "Dorian", "Pelog", "Wholetone"], repeat: 2 },
      { name: "Notes", key: "notes", labels: ["This", "was", "an", "old", "idea", "i", "dropped "], repeat: 2 },
      { name: "Range", key: "range", labels: ["1", "2", "3", "4"], repeat: 2 },
      { name: "Note Length", key: "notelen", labels: ["Blip", "25%", "50%", "75%", "Full", "← → Short", "← → Long"], repeat: 2 },
      { name: "Loop Length", key: "looplen", labels: ["2", "4", "8", "16"], repeat: 2 },
      { name: "Pulse 1 Mode", key: "pulseMode1", labels: ["Off", "On"], repeat: 2 },
      { name: "Pulse 2 Mode", key: "pulseMode2", labels: ["Off", "On"], repeat: 2 },
    ];

    const EDITOR_MAJOR_VERSION = 0x00;
    const EDITOR_MINOR_VERSION = 0x01;
    const EDITOR_POINT_VERSION = 0x00;

    const CARD_LATEST_MAJOR_VERSION = 0x00;
    const CARD_LATEST_MINOR_VERSION = 0x00;
    const CARD_LATEST_POINT_VERSION = 0x09;
    
    let uiReady = false;

    let cardVersion = { major: "0", minor: "1", point: "5" }; // placeholder
    const currentValues = {};
    let midiOutput = null;

    async function initMIDI() {
      try {
        const access = await navigator.requestMIDIAccess({ sysex: true });

        access.onstatechange = () => {
          updateMIDIDeviceStatus(access);
        };

        updateMIDIDeviceStatus(access);

        access.inputs.forEach(input => {
          input.onmidimessage = handleMIDIMessage;
        });

        if (midiOutput) {
          sendConfigRequest();
        }
      } catch (err) {
        console.error("Failed to access Web MIDI:", err);
        document.getElementById("midiError").textContent = "MIDI access denied or unavailable.";
        document.getElementById("midiError").style.display = "block";
      }
    }

    function updateMIDIDeviceStatus(access) {
      const outputs = [...access.outputs.values()];
      const errorEl = document.getElementById("midiError");
      const configEl = document.getElementById("config");


      if (outputs.length === 0) {
        midiOutput = null;
        errorEl.style.display = "block";
        configEl.style.display = "none";
      } else {
        const previouslyDisconnected = !midiOutput;
        midiOutput = outputs[0];
        errorEl.style.display = "none";
        configEl.style.display = "grid"; // or "block" if needed
        if (previouslyDisconnected) {
          sendConfigRequest();
        }
      }
    }

    function sendConfigRequest() {
      if (!midiOutput) return;
      const msg = [0xF0, 0x7D, 0x01, 0x01, 0xF7];
      console.log("Sending config request:", hexArray(msg));
      midiOutput.send(msg);
    }

    function sendFullConfig() {
      if (!midiOutput) return;
      const raw = getConfigBytes();
      const payload = encode7BitSysex(raw);
      const msg = [0xF0, 0x7D, 0x01, 0x03, ...payload, 0xF7];
      console.log("Sending full config:", hexArray(msg));
      midiOutput.send(msg);
    }

    function getConfigBytes() {
      const CONFIG_SIZE = 22;
      const buf = new Uint8Array(CONFIG_SIZE);
      const view = new DataView(buf.buffer);
      view.setUint32(0, 0x434F4E46, true);
      view.setUint16(4, 1605, true);
      buf[6] = 5;
      buf[7] = 0;

      let i = 8;
      for (let p = 0; p < 2; p++) {
        for (const setting of presets) {
          if (p < setting.repeat) {
            const field = `preset${p}.${setting.key}`;
            buf[i++] = currentValues[field] || 0;
          }
        }
      }
      return buf;
    }

    function encode7BitSysex(data) {
      const encoded = [];
      for (let i = 0; i < data.length; i += 7) {
        let msb = 0;
        const block = [];
        for (let j = 0; j < 7; j++) {
          let byte = data[i + j] || 0;
          if (byte & 0x80) msb |= (1 << j);
          block.push(byte & 0x7F);
        }
        encoded.push(msb, ...block);
      }
      return encoded;
    }

    function decode7BitSysex(data) {
      const result = [];
      for (let i = 0; i < data.length;) {
        const msb = data[i++];
        for (let j = 0; j < 7 && i < data.length; j++) {
          let b = data[i++];
          if (msb & (1 << j)) b |= 0x80;
          result.push(b);
        }
      }
      return result;
    }

    function handleMIDIMessage(e) {
      const d = [...e.data];
      if (d[0] !== 0xF0 || d[1] !== 0x7D || d[2] !== 0x01 || d[d.length - 1] !== 0xF7) {
        console.warn("Ignored non-matching SysEx:", hexArray(d));
        return;
      }

      const command = d[3];
      const payload = d.slice(4, d.length - 1);

      console.log(`Incoming SysEx Command 0x${command.toString(16)}:`, hexArray(d));

      if (command === 0x02) {
        const decoded = decode7BitSysex(payload);
        console.log("Decoded config:", hexArray(decoded));
        applyConfig(decoded);
      }
    }

function applyConfig(data) {
  // Delay until UI is ready
  if (!uiReady) {
    setTimeout(() => applyConfig(data), 50);
    return;
  }

  const offset = 8;
  let i = offset;
  const maxPresets = Math.max(...presets.map(p => p.repeat || 1));

  for (let p = 0; p < maxPresets; p++) {
    for (const setting of presets) {
      if (p < setting.repeat) {
        const field = `preset${p}.${setting.key}`;
        currentValues[field] = data[i++];
      }
    }
  }

  updateUI();
}

    function sendUpdate(field, value) {
      currentValues[field] = value;
      updateUI();
      sendFullConfig();
    }

    function updateUI() {
      document.querySelectorAll("button").forEach(btn => {
        const field = btn.dataset.field;
        const value = parseInt(btn.dataset.value);
        btn.classList.toggle("active", currentValues[field] === value);
      });
    }

    function buildConfigUI() {
      const container = document.getElementById("config");
      const maxPresets = Math.max(...presets.map(p => p.repeat || 1));
      document.documentElement.style.setProperty("--preset-count", maxPresets);

      container.appendChild(document.createElement("div")); // top-left corner
      for (let i = 0; i < maxPresets; i++) {
        const header = document.createElement("div");
        header.className = "grid-header";
        header.textContent = i === 0 ? "Switch Mid" : "Switch Up";
        container.appendChild(header);
      }

      presets.forEach(setting => {
        const label = document.createElement("div");
        label.className = "field-label";
        label.textContent = setting.name;
        container.appendChild(label);

        for (let i = 0; i < maxPresets; i++) {
          const cell = document.createElement("div");
          cell.className = "field-cell";

          if (i < setting.repeat) {
            const fieldName = `preset${i}.${setting.key}`;
            setting.labels.forEach((labelText, valueIndex) => {
              const btn = document.createElement("button");
              btn.innerText = labelText;
              btn.dataset.field = fieldName;
              btn.dataset.value = valueIndex;
              btn.onclick = () => sendUpdate(fieldName, valueIndex);
              cell.appendChild(btn);
            });
          }

          container.appendChild(cell);
        }
      });
    }

    function hexArray(arr) {
      return arr.map(x => x.toString(16).padStart(2, "0")).join(" ");
    }

    function displayVersionInfo() {
      const editorVersion = `${EDITOR_MAJOR_VERSION}.${EDITOR_MINOR_VERSION}.${EDITOR_POINT_VERSION}`;
      const card = `${cardVersion.major}.${cardVersion.minor}.${cardVersion.point}`;
      const versionText = `Editor v${editorVersion} — Program Card v${card}`;
      const statusSpan = document.createElement("span");

      const current = [
        parseInt(cardVersion.major),
        parseInt(cardVersion.minor),
        parseInt(cardVersion.point)
      ];
      const latest = [
        CARD_LATEST_MAJOR_VERSION,
        CARD_LATEST_MINOR_VERSION,
        CARD_LATEST_POINT_VERSION
      ];

      let isUpgradeAvailable = false;
      for (let i = 0; i < 3; i++) {
        if (current[i] < latest[i]) {
          isUpgradeAvailable = true;
          break;
        } else if (current[i] > latest[i]) {
          break;
        }
      }

      if (isUpgradeAvailable) {
        statusSpan.innerHTML = ` <a href="http://www.musicthing.co.uk/latest/" target="_blank" style="
          background-color: red;
          color: white;
          padding: 0.1em 0.4em;
          border-radius: 0.2em;
          text-decoration: none;
          font-weight: bold;
          margin-left: 0.5em;
        ">UPGRADE AVAILABLE</a>`;
      } else {
        statusSpan.innerHTML = ` <span style="
          background-color: limegreen;
          color: black;
          padding: 0.1em 0.4em;
          border-radius: 0.2em;
          font-weight: bold;
          margin-left: 0.5em;
        ">LATEST</span>`;
      }

      const info = document.getElementById("versionInfo");
      info.textContent = versionText;
      info.appendChild(statusSpan);
    }

    buildConfigUI();
    uiReady = true; // UI is now safe to update
    initMIDI();
    displayVersionInfo();
  </script>
</body>
</html>
