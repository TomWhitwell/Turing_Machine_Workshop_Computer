<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Turing Machine Editor</title>
  <link href="https://fontlibrary.org/face/osp-din" rel="stylesheet" type="text/css">

<style>
  :root {
    --bg: #000;
    --text: #fff;
    --accent: #d4af37;
  }

  body {
    font-family: 'OSP-DIN', sans-serif;
    background-color: var(--bg);
    color: var(--text);
    margin: 0;
    padding: 2rem;
  }

  h1 {
    text-transform: uppercase;
    font-weight: normal;
    letter-spacing: 1px;
    font-size: 2.5em;
    margin: 0 0 0.5rem 0;
  }

  #versionInfo {
    font-size: 1rem;
    color: var(--accent);
    margin-bottom: 1rem;
  }

  #midiError {
    color: red;
    font-weight: bold;
    margin-bottom: 2rem;
    display: none;
  }

  .config-grid {
    display: grid;
    grid-template-columns: auto repeat(var(--preset-count, 2), 1fr);
    gap: 2rem;
  }

  .grid-header,
  .field-label {
    text-transform: uppercase;
    font-weight: bold;
    font-size: 1.25em;
  }

  .field-label {
    border-left: 4px solid var(--accent);
    padding-left: 1rem;
  }

  .field-cell {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
  }

  button {
    font-family: 'OSP-DIN', sans-serif;
    font-size: 1.2em;
    background-color: var(--bg);
    color: var(--text);
    border: 2px solid var(--accent);
    padding: 0.7em 1.2em;
    cursor: pointer;
    transition: all 0.2s;
    text-transform: uppercase;
  }

  button:hover {
    background-color: #111;
  }

  button.active {
    background-color: var(--text);
    color: var(--bg);
    border-color: var(--text);
  }

  @media (max-width: 800px) {
    .config-grid {
      grid-template-columns: auto 1fr;
    }
    .config-grid .grid-header:nth-child(n+3),
    .config-grid .field-cell:nth-child(3n+3) {
      display: none;
    }

    .visualizer-container {
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: auto;
      justify-items: center;
      border: none;
    }

    .visualizer {
      border: none !important;
      align-items: center;
    }
  }

  /* --- Visualizer block styles --- */

  .visualizer-area {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    margin-bottom: 2rem;
  }

  .top-bar {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    flex-wrap: wrap;
    gap: 2rem;
    margin-bottom: 2rem;
    width: 100%;
  }

  .title-block {
    flex: 1;
    min-width: 200px;
  }

  .visualizer-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: auto auto;
    gap: 0;
    align-items: start;
    justify-items: end;
grid-column: 2;
  }

  .visualizer {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    padding: 0.5rem 1rem;
    position: relative;
  }

  /* Vertical line between columns */
  .visualizer:nth-child(2),
  .visualizer:nth-child(4) {
    border-left: 1px solid var(--accent);
  }

  /* Horizontal line between rows */
  .visualizer:nth-child(3),
  .visualizer:nth-child(4) {
    border-top: 1px solid var(--accent);
  }

  .visualizer-label {
    text-align: center;
    margin-bottom: 0.25rem;
    font-weight: bold;
  }

  .visualizer .bits {
    display: flex;
    gap: 2px;
    justify-content: center;
    margin-bottom: 0.5rem;
  }

  .visualizer .bit {
    width: 13px;
    height: 13px;
    background: black;
    display: inline-block;
    border-radius: 50%;
  }

  .page-layout {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
  }

  .main-layout {
    display: flex;
    align-items: flex-start;
    gap: 2rem;
    flex-wrap: wrap;
  }

  .config-side {
    flex: 1 1 600px;
    min-width: 300px;
  }
</style>



</head>
<body>
<div class="page-layout">

<div class="top-bar">
  <div class="title-block">
    <h1>Turing Machine Editor</h1>
    <p id="versionInfo">Loading version info...</p>
  </div>
  <div id="visualizerContainer" class="visualizer-container"></div>
</div>
  
  
  <p id="midiError">No MIDI device connected.</p>
  <div id="config" class="config-grid"></div>

</div>

  <script>
  const presets = [
    { name: "Scale", key: "scale", labels: ["Chrom", "Major", "Minor", "Minor Pent", "Dorian", "Pelog", "Wholetone"], repeat: 2 },
    { name: "Notes", key: "notes", labels: ["This", "was", "an", "old", "idea", "i", "dropped "], repeat: 2 },
    { name: "Range", key: "range", labels: ["1", "2", "3", "4"], repeat: 2 },
    { name: "Note Length", key: "notelen", labels: ["Blip", "25%", "50%", "75%", "Full", "← → Short", "← → Long"], repeat: 2 },
    { name: "Loop Length", key: "looplen", labels: ["2", "4", "8", "16"], repeat: 2 },
    { name: "Pulse 1 Mode", key: "pulseMode1", labels: ["Off", "On"], repeat: 2 },
    { name: "Pulse 2 Mode", key: "pulseMode2", labels: ["Off", "On"], repeat: 2 },
  ];

  const EDITOR_MAJOR_VERSION = 0x00;
  const EDITOR_MINOR_VERSION = 0x01;
  const EDITOR_POINT_VERSION = 0x00;

  const CARD_LATEST_MAJOR_VERSION = 0x00;
  const CARD_LATEST_MINOR_VERSION = 0x00;
  const CARD_LATEST_POINT_VERSION = 0x09;

  let uiReady = false;

  let cardVersion = { major: "0", minor: "1", point: "5" }; // placeholder
  const currentValues = {};
  let midiOutput = null;

  async function initMIDI() {
    try {
      const access = await navigator.requestMIDIAccess({ sysex: true });

      access.onstatechange = () => updateMIDIDeviceStatus(access);
      updateMIDIDeviceStatus(access);

      access.inputs.forEach(input => {
        input.onmidimessage = handleMIDIMessage;
      });

      if (midiOutput) {
        sendConfigRequest();
      }
    } catch (err) {
      console.error("Failed to access Web MIDI:", err);
      document.getElementById("midiError").textContent = "MIDI access denied or unavailable.";
      document.getElementById("midiError").style.display = "block";
    }
  }

  function updateMIDIDeviceStatus(access) {
    const outputs = [...access.outputs.values()];
    const errorEl = document.getElementById("midiError");
    const configEl = document.getElementById("config");

    if (outputs.length === 0) {
      midiOutput = null;
      errorEl.style.display = "block";
      configEl.style.display = "none";
    } else {
      const previouslyDisconnected = !midiOutput;
      midiOutput = outputs[0];
      errorEl.style.display = "none";
      configEl.style.display = "grid";
      if (previouslyDisconnected) sendConfigRequest();
    }
  }

  function sendConfigRequest() {
    if (!midiOutput) return;
    const msg = [0xF0, 0x7D, 0x01, 0x01, 0xF7];
    console.log("Sending config request:", hexArray(msg));
    midiOutput.send(msg);
  }

  function sendFullConfig() {
    if (!midiOutput) return;
    const raw = getConfigBytes();
    const payload = encode7BitSysex(raw);
    const msg = [0xF0, 0x7D, 0x01, 0x03, ...payload, 0xF7];
    console.log("Sending full config:", hexArray(msg));
    midiOutput.send(msg);
  }

  function getConfigBytes() {
    const CONFIG_SIZE = 22;
    const buf = new Uint8Array(CONFIG_SIZE);
    const view = new DataView(buf.buffer);
    view.setUint32(0, 0x434F4E46, true);
    view.setUint16(4, 1605, true);
    buf[6] = 5;
    buf[7] = 0;

    let i = 8;
    for (let p = 0; p < 2; p++) {
      for (const setting of presets) {
        if (p < setting.repeat) {
          const field = `preset${p}.${setting.key}`;
          buf[i++] = currentValues[field] || 0;
        }
      }
    }
    return buf;
  }

  function encode7BitSysex(data) {
    const encoded = [];
    for (let i = 0; i < data.length; i += 7) {
      let msb = 0;
      const block = [];
      for (let j = 0; j < 7; j++) {
        let byte = data[i + j] || 0;
        if (byte & 0x80) msb |= (1 << j);
        block.push(byte & 0x7F);
      }
      encoded.push(msb, ...block);
    }
    return encoded;
  }

  function decode7BitSysex(data) {
    const result = [];
    for (let i = 0; i < data.length;) {
      const msb = data[i++];
      for (let j = 0; j < 7 && i < data.length; j++) {
        let b = data[i++];
        if (msb & (1 << j)) b |= 0x80;
        result.push(b);
      }
    }
    return result;
  }

  function handleMIDIMessage(e) {
    const d = [...e.data];
    if (d[0] !== 0xF0 || d[1] !== 0x7D || d[2] !== 0x01 || d[d.length - 1] !== 0xF7) return;

    const command = d[3];
    const payload = d.slice(4, d.length - 1);
    if (command === 0x02) {
      const decoded = decode7BitSysex(payload);
      applyConfig(decoded);
    } else if (command === 0x10) {
    console.log("handling status message:", hexArray(payload));
      handleStatusMessage(payload);
    }
  }

  function applyConfig(data) {
    if (!uiReady) {
      setTimeout(() => applyConfig(data), 50);
      return;
    }

    const offset = 8;
    let i = offset;
    const maxPresets = Math.max(...presets.map(p => p.repeat || 1));
    for (let p = 0; p < maxPresets; p++) {
      for (const setting of presets) {
        if (p < setting.repeat) {
          const field = `preset${p}.${setting.key}`;
          currentValues[field] = data[i++];
        }
      }
    }
    updateUI();
  }

  function sendUpdate(field, value) {
    currentValues[field] = value;
    updateUI();
    sendFullConfig();
  }

      function hexArray(arr) {
      return arr.map(x => x.toString(16).padStart(2, "0")).join(" ");
    }

  function updateUI() {
    document.querySelectorAll("button").forEach(btn => {
      const field = btn.dataset.field;
      const value = parseInt(btn.dataset.value);
      btn.classList.toggle("active", currentValues[field] === value);
    });
  }

  function buildConfigUI() {
    const container = document.getElementById("config");
    const maxPresets = Math.max(...presets.map(p => p.repeat || 1));
    document.documentElement.style.setProperty("--preset-count", maxPresets);

    container.appendChild(document.createElement("div"));
    for (let i = 0; i < maxPresets; i++) {
      const header = document.createElement("div");
      header.className = "grid-header";
      header.textContent = i === 0 ? "Switch Mid" : "Switch Up";
      container.appendChild(header);
    }

    presets.forEach(setting => {
      const label = document.createElement("div");
      label.className = "field-label";
      label.textContent = setting.name;
      container.appendChild(label);

      for (let i = 0; i < maxPresets; i++) {
        const cell = document.createElement("div");
        cell.className = "field-cell";

        if (i < setting.repeat) {
          const fieldName = `preset${i}.${setting.key}`;
          setting.labels.forEach((labelText, valueIndex) => {
            const btn = document.createElement("button");
            btn.innerText = labelText;
            btn.dataset.field = fieldName;
            btn.dataset.value = valueIndex;
            btn.onclick = () => sendUpdate(fieldName, valueIndex);
            cell.appendChild(btn);
          });
        }
        container.appendChild(cell);
      }
    });
  }

  const visualizers = [];


function setupLiveStatusVisualizers() {
  const container = document.createElement("div");
  container.className = "visualizer-container";

  const visualizerLabels = ["CV/Audio 1", "CV/Audio 2", "CV 1", "CV 2"];

  for (let i = 0; i < 4; i++) {
    const vizEl = document.createElement("div");
    vizEl.className = "visualizer";

    // Create label element
    const label = document.createElement("div");
    label.className = "visualizer-label";
    label.textContent = visualizerLabels[i];

    // Use innerHTML for rest of visualizer layout
    vizEl.innerHTML = `
      <div class="bits" id="bits-${i}"></div>
      <svg id="sparkline-${i}" viewBox="0 0 104 40" preserveAspectRatio="none">
        <g id="baseline-${i}"></g>
        <g id="sparkline-path-${i}"></g>
      </svg>
    `;

    // Re-insert label at the top *after* innerHTML (which would overwrite it otherwise)
    vizEl.insertBefore(label, vizEl.firstChild);

    container.appendChild(vizEl);

    setTimeout(() => {
      visualizers.push(createVisualizer(i, i < 2));
    }, 0);
  }

//   // Instead of: document.body.appendChild(container);
//   const topContainer = document.createElement("div");
//   topContainer.className = "top-bar";
// 
//   const title = document.querySelector("h1");
//   const visualizerContainer = container;
// 
// topContainer.appendChild(visualizerContainer);
// title.parentNode.insertBefore(topContainer, title.nextSibling);
// Append visualizerContainer (already in DOM)
const visualizerContainer = document.getElementById("visualizerContainer");
visualizerContainer.appendChild(container);



}

  function createVisualizer(index, bipolar = false) {
    const bitContainer = document.getElementById(`bits-${index}`);
    const pathContainer = document.getElementById(`sparkline-path-${index}`);
    const baselineContainer = document.getElementById(`baseline-${index}`);
    const bits = [];
    for (let i = 0; i < 8; i++) {
      const bit = document.createElement('div');
      bit.className = 'bit';
      bitContainer.appendChild(bit);
      bits.push(bit);
    }

    const history = new Array(32).fill(0);
    const w = 104;
    const h = 40;
    const step = w / 31;
    const baselineY = bipolar ? h - ((127 / 255) * h) : h;
    const baselinePath = document.createElementNS("http://www.w3.org/2000/svg", "line");
    baselinePath.setAttribute("x1", "0");
    baselinePath.setAttribute("x2", w);
    baselinePath.setAttribute("y1", baselineY);
    baselinePath.setAttribute("y2", baselineY);
    baselinePath.setAttribute("stroke", "#555");
    baselinePath.setAttribute("stroke-width", "1");
    baselinePath.setAttribute("stroke-dasharray", "2,2");
    baselineContainer.appendChild(baselinePath);

    function drawBits(val) {
      for (let i = 0; i < 8; i++) {
        const isSet = (val & (1 << (7 - i))) !== 0;
        bits[i].style.background = isSet ? 'red' : 'black';
      }
    }

    function drawSparkline() {
      pathContainer.innerHTML = '';
      for (let i = 0; i < 31; i++) {
        const v1 = history[i];
        const v2 = history[i + 1];
        const x1 = i * step;
        const x2 = (i + 1) * step;
        const y1 = h - (v1 / 255) * h;
        const y2 = h - (v2 / 255) * h;
        const fade = i / 31;
        const gray = Math.round(fade * 255);
        const color = `rgb(${gray},${gray},${gray})`;

        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("stroke", color);
        path.setAttribute("stroke-width", "2");
        path.setAttribute("fill", "none");
        path.setAttribute("d", `M${x1},${y1} H${x2} V${y2}`);
        pathContainer.appendChild(path);
      }
    }

    function update(val) {
      history.push(val);
      if (history.length > 32) history.shift();
      drawBits(val);
      drawSparkline();
    }

    return { update };
  }

  function handleStatusMessage(payload) {
    if (payload.length < 11) return;
    const values = [
      (payload[0] << 7) | payload[1],
      (payload[2] << 7) | payload[3],
      (payload[4] << 7) | payload[5],
      (payload[6] << 7) | payload[7],
      payload[8],
      payload[9],
      payload[10]
    ];
    
  console.log(
  "DAC1: %d\tDAC2: %d\tPWM1: %d\tPWM2: %d",
  values[0],
  values[1],
  values[2],
  values[3]
  );
    visualizers[0].update(values[0]);
    visualizers[1].update(values[1]);
    visualizers[2].update(values[2]);
    visualizers[3].update(values[3]);
  }

  function displayVersionInfo() {
    const editorVersion = `${EDITOR_MAJOR_VERSION}.${EDITOR_MINOR_VERSION}.${EDITOR_POINT_VERSION}`;
    const card = `${cardVersion.major}.${cardVersion.minor}.${cardVersion.point}`;
    const versionText = `Editor v${editorVersion} — Program Card v${card}`;
    const statusSpan = document.createElement("span");
    const current = [
      parseInt(cardVersion.major),
      parseInt(cardVersion.minor),
      parseInt(cardVersion.point)
    ];
    const latest = [
      CARD_LATEST_MAJOR_VERSION,
      CARD_LATEST_MINOR_VERSION,
      CARD_LATEST_POINT_VERSION
    ];
    let isUpgradeAvailable = false;
    for (let i = 0; i < 3; i++) {
      if (current[i] < latest[i]) {
        isUpgradeAvailable = true;
        break;
      } else if (current[i] > latest[i]) {
        break;
      }
    }
    if (isUpgradeAvailable) {
      statusSpan.innerHTML = ` <a href="http://www.musicthing.co.uk/latest/" target="_blank" style="background-color: red; color: white; padding: 0.1em 0.4em; border-radius: 0.2em; text-decoration: none; font-weight: bold; margin-left: 0.5em;">UPGRADE AVAILABLE</a>`;
    } else {
      statusSpan.innerHTML = ` <span style="background-color: limegreen; color: black; padding: 0.1em 0.4em; border-radius: 0.2em; font-weight: bold; margin-left: 0.5em;">LATEST</span>`;
    }
    const info = document.getElementById("versionInfo");
    info.textContent = versionText;
    info.appendChild(statusSpan);
  }

  // === Initialization ===
  buildConfigUI();
  uiReady = true;
  setupLiveStatusVisualizers();
  initMIDI();
  displayVersionInfo();
  </script>
</body>
</html>
